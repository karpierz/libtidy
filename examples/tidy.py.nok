# **************************************************************************** #
# @file
# HTML TidyLib command line driver.
#
# This console application utilizing LibTidy in order to offer a complete
# console application offering all of the features of LibTidy.
#
# @author  HTACG, et al (consult git log)
# 
# @copyright
#     Copyright (c) 1998-2017 World Wide Web Consortium (Massachusetts
#     Institute of Technology, European Research Consortium for Informatics
#     and Mathematics, Keio University) and HTACG.
# @par
#     All Rights Reserved.
# @par
#     See `tidy.h` for the complete license.
#
# @date Additional updates: consult git log
# **************************************************************************** #

import sys
import os
import ctypes as ct

import libtidy as tidy
from libtidy import TidyDoc, TidyNode, TidyBuffer, TidyMessage, TidyOption
from libtidy._platform import defined, is_windows

#include "locale.h"
#include "sprtf.h"

#if defined(ENABLE_DEBUG_LOG) and defined(_MSC_VER) and defined(_CRTDBG_MAP_ALLOC)
#  include <crtdbg.h>
#endif

# Tidy will send errors to this file, which will be stderr later.
errout = None

if is_windows:
   static uint win_cp;  # original Windows code page
# endif

# @defgroup console_application Tidy Console Application
# @copydoc tidy.c
# @{

class Tidy:

    def __init__(self):
        self.tdoc: TidyDoc = tidy.Create()

    def __del__(self):
        if self.tdoc: tidy.Release(self.tdoc)

    # MARK: - Miscellaneous Utilities
    # **************************************************************************** #
    # @defgroup utilities_misc Miscellaneous Utilities
    # This group contains general utilities used in the console application.
    # **************************************************************************** #
    # @{

    def outOfMemory():
        """Exits with an error in the event of an out of memory condition.
        """
        print("%s" %
              tidy.LocalizedString(tidy.TC_STRING_OUT_OF_MEMORY).decode("utf-8"),
              end="", file=sys.stderr)
        exit(1)

    tmbstr stringWithFormat(const ctmbstr fmt,  # The format string.
                            ...):               # Variable arguments.
        """Create a new, allocated string with a format and arguments.
        @result Returns a new, allocated string that you must free.
        """
        va_list argList;
        tmbstr result = NULL;
        int len = 0;

        va_start(argList, fmt);
        len = vsnprintf( result, 0, fmt, argList );
        va_end(argList);

        if (!(result = malloc( len + 1) ))
            outOfMemory();

        va_start(argList, fmt);
        vsnprintf( result, len + 1, fmt, argList);
        va_end(argList);

        return result;

    # @} end utilities_misc group

    # MARK: - Output Helping Functions
    # **************************************************************************** #
    # @defgroup utilities_output Output Helping Functions
    # This group functions that aid the formatting of output.
    # **************************************************************************** #
    # @{

    @staticmethod
    def print1Column(fmt: str,         # The format string for formatting the output.
                     uint l1,          # The width of the column.
                     const char *c1):  # The content of the column.
        """Outputs one column of text."""

        char *c1buf = (char *)malloc(l1+1);
        if not c1buf: outOfMemory()

        const char *pc1=c1;
        while True:
            pc1 = Tidy.cutToWhiteSpace(pc1, l1, c1buf);
            printf(fmt, c1buf[0] != '\0' ? c1buf : "");
            if not pc1: break

        free(c1buf);

    @staticmethod
    def print2Columns(fmt: str,         # The format string for formatting the output.
                      uint l1,          # The width of column 1.
                      uint l2,          # The width of column 2.
                      const char *c1,   # The contents of column 1.
                      const char *c2):  # The contents of column 2.
        """Outputs two columns of text."""

        char *c1buf = (char *)malloc(l1+1);
        if not c2buf: outOfMemory()
        char *c2buf = (char *)malloc(l2+1);
        if not c1buf: outOfMemory()

        const char *pc1=c1, *pc2=c2;
        while True:
            pc1 = Tidy.cutToWhiteSpace(pc1, l1, c1buf);
            pc2 = Tidy.cutToWhiteSpace(pc2, l2, c2buf);
            printf(fmt, l1, l1, c1buf[0] != '\0' ? c1buf:"",
                        l2, l2, c2buf[0] != '\0' ? c2buf:"")
            if not (pc1 || pc2): break

        free(c1buf);
        free(c2buf);

    @staticmethod
    def print3Columns(fmt: str,         # The three column format string.
                      uint l1,          # Width of column 1.
                      uint l2,          # Width of column 2.
                      uint l3,          # Width of column 3.
                      const char *c1,   # Content of column 1.
                      const char *c2,   # Content of column 2.
                      const char *c3):  # Content of column 3.
        """Outputs three columns of text."""

        char *c1buf = (char *)malloc(l1+1);
        if not c1buf: outOfMemory()
        char *c2buf = (char *)malloc(l2+1);
        if not c2buf: outOfMemory()
        char *c3buf = (char *)malloc(l3+1);
        if not c3buf: outOfMemory()

        const char *pc1=c1, *pc2=c2, *pc3=c3;
        while True:
            pc1 = Tidy.cutToWhiteSpace(pc1, l1, c1buf);
            pc2 = Tidy.cutToWhiteSpace(pc2, l2, c2buf);
            pc3 = Tidy.cutToWhiteSpace(pc3, l3, c3buf);
            printf(fmt,
                   c1buf[0]!='\0' ? c1buf : "",
                   c2buf[0]!='\0' ? c2buf : "",
                   c3buf[0]!='\0' ? c3buf : "")
            if not (pc1 || pc2 || pc3): break

        free(c1buf);
        free(c2buf);
        free(c3buf);

    @staticmethod
    const char * cutToWhiteSpace(const char *s,  # starting point of desired string to output
                                 uint offset,    # column width desired
                                 char *sbuf):    # the buffer to output
        """Used by `print1Column`, `print2Columns` and `print3Columns` to manage 
        wrapping text within columns.
        @result The pointer to the next part of the string to output.
        """
        if not s:
            sbuf[0] = '\0';
            return NULL;
        else if (strlen(s) <= offset)
            strcpy(sbuf,s);
            sbuf[offset] = '\0';
            return NULL;
        else:
            uint j, l, n;
            # scan forward looking for newline
            j = 0;
            while(j < offset and s[j] != '\n')
                ++j;
            if j == offset:
                # scan backward looking for first space
                j = offset;
                while(j and s[j] != ' ')
                    --j;
                l = j;
                n = j+1;
                # no white space
                if j == 0:
                    l = offset;
                    n = offset;
            else:
                l = j;
                n = j+1;
            strncpy(sbuf,s,l);
            sbuf[l] = '\0';
            return s+n;

    def unknownOption(self,
                      uint c):  # The unknown option.
        """Provides the `unknown option` output to the current errout.
        """
        global errout
        print(tidy.LocalizedString(tidy.TC_STRING_UNKNOWN_OPTION).decode("utf-8") %
              (char)c, file=errout)


# @} end utilities_output group

# MARK: - CLI Options Utilities
# **************************************************************************** #
# @defgroup options_cli CLI Options Utilities
# These structures, arrays, declarations, and definitions are used throughout
# this console application.
# **************************************************************************** #
# @{

# @name Format strings and decorations used in output.
# @{

helpfmt: str = " %-*.*s %-*.*s\n"
const char helpul[]  = "-----------------------------------------------------------------";
fmt: str     = "%-27.27s %-9.9s  %-40.40s\n";
const char ul[]      = "=================================================================";

# @}

# This enum is used to categorize the options for help output.
#
typedef enum
{
    CmdOptFileManip,
    CmdOptCatFIRST = CmdOptFileManip,
    CmdOptProcDir,
    CmdOptCharEnc,
    CmdOptMisc,
    CmdOptXML,
    CmdOptCatLAST
} CmdOptCategory;

# This array contains headings that will be used in help output.
#
static const struct {
    ctmbstr mnemonic;   # Used in XML as a class.
    uint key;           # Key to fetch the localized string.
} cmdopt_catname[] = {
    { "file-manip",         tidy.TC_STRING_FILE_MANIP },
    { "process-directives", tidy.TC_STRING_PROCESS_DIRECTIVES },
    { "char-encoding",      tidy.TC_STRING_CHAR_ENCODING },
    { "misc",               tidy.TC_STRING_MISC },
    { "xml",                tidy.TC_STRING_XML }
};

# The struct and subsequent array keep the help output structured
# because we _also_ output all of this stuff as as XML.
#
typedef struct {
    CmdOptCategory cat;  # Category
    ctmbstr name1;       # Name
    uint key;            # Key to fetch the localized description.
    uint subKey;         # Secondary substitution key.
    ctmbstr eqconfig;    # Equivalent configuration option
    ctmbstr name2;       # Name
    ctmbstr name3;       # Name
} CmdOptDesc;

# All instances of %s will be substituted with localized string
# specified by the subKey field.
#
static const CmdOptDesc cmdopt_defs[] =  {
    { CmdOptFileManip, "-output <%s>",           TC_OPT_OUTPUT,   TC_LABEL_FILE, "output-file: <%s>", "-o <%s>" },
    { CmdOptFileManip, "-config <%s>",           TC_OPT_CONFIG,   TC_LABEL_FILE, NULL },
    { CmdOptFileManip, "-file <%s>",             TC_OPT_FILE,     TC_LABEL_FILE, "error-file: <%s>", "-f <%s>" },
    { CmdOptFileManip, "-modify",                TC_OPT_MODIFY,   0,             "write-back: yes", "-m" },
    { CmdOptProcDir,   "-indent",                TC_OPT_INDENT,   0,             "indent: auto", "-i" },
    { CmdOptProcDir,   "-wrap <%s>",             TC_OPT_WRAP,     TC_LABEL_COL,  "wrap: <%s>", "-w <%s>" },
    { CmdOptProcDir,   "-upper",                 TC_OPT_UPPER,    0,             "uppercase-tags: yes", "-u" },
    { CmdOptProcDir,   "-clean",                 TC_OPT_CLEAN,    0,             "clean: yes", "-c" },
    { CmdOptProcDir,   "-bare",                  TC_OPT_BARE,     0,             "bare: yes", "-b" },
    { CmdOptProcDir,   "-gdoc",                  TC_OPT_GDOC,     0,             "gdoc: yes", "-g" },
    { CmdOptProcDir,   "-numeric",               TC_OPT_NUMERIC,  0,             "numeric-entities: yes", "-n" },
    { CmdOptProcDir,   "-errors",                TC_OPT_ERRORS,   0,             "markup: no", "-e" },
    { CmdOptProcDir,   "-quiet",                 TC_OPT_QUIET,    0,             "quiet: yes", "-q" },
    { CmdOptProcDir,   "-omit",                  TC_OPT_OMIT,     0,             "omit-optional-tags: yes" },
    { CmdOptProcDir,   "-xml",                   TC_OPT_XML,      0,             "input-xml: yes" },
    { CmdOptProcDir,   "-asxml",                 TC_OPT_ASXML,    0,             "output-xhtml: yes", "-asxhtml" },
    { CmdOptProcDir,   "-ashtml",                TC_OPT_ASHTML,   0,             "output-html: yes" },
    { CmdOptProcDir,   "-access <%s>",           TC_OPT_ACCESS,   TC_LABEL_LEVL, "accessibility-check: <%s>" },
    { CmdOptCharEnc,   "-raw",                   TC_OPT_RAW,      0,             NULL },
    { CmdOptCharEnc,   "-ascii",                 TC_OPT_ASCII,    0,             NULL },
    { CmdOptCharEnc,   "-latin0",                TC_OPT_LATIN0,   0,             NULL },
    { CmdOptCharEnc,   "-latin1",                TC_OPT_LATIN1,   0,             NULL },
#ifndef NO_NATIVE_ISO2022_SUPPORT
    { CmdOptCharEnc,   "-iso2022",               TC_OPT_ISO2022,  0,             NULL },
#endif
    { CmdOptCharEnc,   "-utf8",                  TC_OPT_UTF8,     0,             NULL },
    { CmdOptCharEnc,   "-mac",                   TC_OPT_MAC,      0,             NULL },
    { CmdOptCharEnc,   "-win1252",               TC_OPT_WIN1252,  0,             NULL },
    { CmdOptCharEnc,   "-ibm858",                TC_OPT_IBM858,   0,             NULL },
    { CmdOptCharEnc,   "-utf16le",               TC_OPT_UTF16LE,  0,             NULL },
    { CmdOptCharEnc,   "-utf16be",               TC_OPT_UTF16BE,  0,             NULL },
    { CmdOptCharEnc,   "-utf16",                 TC_OPT_UTF16,    0,             NULL },
    { CmdOptCharEnc,   "-big5",                  TC_OPT_BIG5,     0,             NULL },
    { CmdOptCharEnc,   "-shiftjis",              TC_OPT_SHIFTJIS, 0,             NULL },
    { CmdOptMisc,      "-version",               TC_OPT_VERSION,  0,             NULL,  "-v" },
    { CmdOptMisc,      "-help",                  TC_OPT_HELP,     0,             NULL,  "-h", "-?" },
    { CmdOptMisc,      "-help-config",           TC_OPT_HELPCFG,  0,             NULL },
    { CmdOptMisc,      "-help-env",              TC_OPT_HELPENV,  0,             NULL },
    { CmdOptMisc,      "-show-config",           TC_OPT_SHOWCFG,  0,             NULL },
    { CmdOptMisc,      "-export-config",         TC_OPT_EXP_CFG,  0,             NULL },
    { CmdOptMisc,      "-export-default-config", TC_OPT_EXP_DEF,  0,             NULL },
    { CmdOptMisc,      "-help-option <%s>",      TC_OPT_HELPOPT,  TC_LABEL_OPT,  NULL },
    { CmdOptMisc,      "-language <%s>",         TC_OPT_LANGUAGE, TC_LABEL_LANG, "language: <%s>" },
    { CmdOptXML,       "-xml-help",              TC_OPT_XMLHELP,  0,             NULL },
    { CmdOptXML,       "-xml-config",            TC_OPT_XMLCFG,   0,             NULL },
    { CmdOptXML,       "-xml-strings",           TC_OPT_XMLSTRG,  0,             NULL },
    { CmdOptXML,       "-xml-error-strings",     TC_OPT_XMLERRS,  0,             NULL },
    { CmdOptXML,       "-xml-options-strings",   TC_OPT_XMLOPTS,  0,             NULL },
    { CmdOptMisc,      NULL,                   0,               0,             NULL }
};


def localize_option_names(CmdOptDesc *pos):
    """Option names aren't localized, but the sample fields should be localized.
    For example, `<file>` should be `<archivo>` in Spanish.
    @param pos A CmdOptDesc array with fields that must be localized.
    """
    ctmbstr fileString = tidy.LocalizedString(pos->subKey).decode("utf-8")
    pos->name1 = stringWithFormat(pos->name1, fileString);
    if pos->name2:
        pos->name2 = stringWithFormat(pos->name2, fileString);
    if pos->name3:
        pos->name3 = stringWithFormat(pos->name3, fileString);
    if pos->eqconfig:
        pos->eqconfig = stringWithFormat(pos->eqconfig, fileString);


def get_escaped_name( ctmbstr name ) -> str:
    """Escape a name for XML output.
    For example, `-output <file>` becomes
    `-output &lt;file&gt;` for use in XML.
    @param name The option name to escape.
    @result Returns an allocated string.
    """
    tmbstr escpName;
    char aux[2];
    uint len = 0;
    ctmbstr c;
    for ( c=name; *c!='\0'; ++c ):
        switch(*c)
        {
        case '<':
        case '>':
            len += 4;
            break;
        case '"':
            len += 6;
            break;
        default:
            len += 1;
            break;
        }

    escpName = (tmbstr)malloc(len+1);
    if (!escpName) outOfMemory();
    escpName[0] = '\0';

    aux[1] = '\0';
    for ( c=name; *c!='\0'; ++c ):
        switch(*c)
        {
        case '<':
            strcat(escpName, "&lt;");
            break;
        case '>':
            strcat(escpName, "&gt;");
            break;
        case '"':
            strcat(escpName, "&quot;");
            break;
        default:
            aux[0] = *c;
            strcat(escpName, aux);
            break;
        }

    return escpName.decode("utf-8")


# @} end CLI Options Definitions Utilities group

# MARK: - Configuration Options Utilities
# **************************************************************************** #
# @defgroup utilities_cli_options Configuration Options Utilities
# Provide utilities to manipulate configuration options for output.
# **************************************************************************** #
# @{


def hasPickList(topt: TidyOption) -> bool:
    """Utility to determine if an option has a picklist.
    @param topt The option to check.
    @result Returns a Bool indicating whether the option has a picklist or not.
    """
    if tidyOptGetType(topt) != tidy.TidyInteger:
        return False
    
    pos: TidyIterator = tidyOptGetPickList( topt );
    
    return tidyOptGetNextPick( topt, &pos ) != NULL;


ctmbstr ConfigCategoryId( TidyConfigCategory id ):
    """Returns the configuration category id for the specified configuration
    category id. This will be used as an XML class attribute value.
    @param id The TidyConfigCategory for which to lookup the category name.
    @result Returns the configuration category, such as "diagnostics".
    """
    if id >= TidyDiagnostics and id <= tidy.TidyInternalCategory:
        return tidyErrorCodeAsKey( id );

    fprintf(sys.stderr, tidy.LocalizedString(tidy.TC_STRING_FATAL_ERROR),
            (int)id)
    fprintf(sys.stderr, "\n")

    assert(0);
    abort();
    return "never_here";  # only for the compiler warning


# Structure maintains a description of a configuration ption.
#
typedef struct {
    ctmbstr name;          # Name
    ctmbstr cat;           # Category
    uint    catid;         # Category ID
    ctmbstr type;          # "String, ...
    ctmbstr vals;          # Potential values. If NULL, use an external function
    ctmbstr def;           # default
    tmbchar tempdefs[80];  # storage for default such as integer
    Bool haveVals;         # if yes, vals is valid
} OptionDesc;

# A type for a function pointer for a function used to print out options 
# descriptions.
# @param TidyDoc The document.
# @param TidyOption The Tidy option.
# @param OptionDesc A pointer to the option description structure.
#
OptionFunc = typedef void (*)( TidyDoc, TidyOption, OptionDesc * );



typedef struct {
    """Array holding all options. Contains a trailing sentinel."""
    TidyOption topt[tidy.N_TIDY_OPTIONS];
} AllOption_t;

int cmpOpt(const void* e1_,   # Item A to compare.
           const void *e2_):  # Item B to compare.
    """A simple option comparator, used for sorting the options.
    @result Returns an integer indicating the result of the comparison.
    """
    const TidyOption* e1 = (const TidyOption*)e1_;
    const TidyOption* e2 = (const TidyOption*)e2_;
    return strcmp(tidyOptGetName(*e1), tidyOptGetName(*e2));


    def getSortedOption(self) -> AllOption_t:  # [out] The list of options.
        """Returns options sorted.
        """
        tOption = AllOption_t()
        i = 0
        pos: TidyIterator = tidy.GetOptionList(self.tdoc)
        while pos:
            topt: TidyOption = tidy.GetNextOption(self.tdoc, ct.byref(pos))
            tOption.topt[i] = topt;
            i += 1
        tOption.topt[i] = NULL;  # sentinel

        qsort(tOption.topt,
              i,  # there are i items, not including the sentinel
              sizeof(tOption.topt[0]),
              cmpOpt);

        return tOption

    def ForEachOption(self,             # The Tidy document.
                      OptionFunc OptionPrint):  # The printing function to be used.
        """An iterator for the unsorted options.
        """
        pos: TidyIterator = tidy.GetOptionList(self.tdoc)
        while pos:
            topt: TidyOption = tidy.GetNextOption(self.tdoc, ct.byref(pos))
            d: OptionDesc = self.tdoc.GetOption(topt)
            (*OptionPrint)( self.tdoc, topt, &d );

    def ForEachSortedOption(self,             # The Tidy document.
                            OptionFunc OptionPrint):  # The printing function to be used.
        """An iterator for the sorted options.
        """
        tOption: AllOption_t = self.getSortedOption()
        const TidyOption *topt;
        for( topt = tOption.topt; *topt; ++topt ):
            d: OptionDesc = self.tdoc.GetOption(*topt)
            (*OptionPrint)( self.tdoc, *topt, &d );

    def GetOption(self,
                  topt: TidyOption # The option to create a description for.
                 ) -> OptionDesc:  # The new option description.
        """Create OptionDesc "d" related to "opt"
        """
        optId:  TidyOptionId   = tidy.OptGetId(topt)
        optTyp: TidyOptionType = tidyOptGetType(topt)

        d = OptionDesc()
        d.name  = tidyOptGetName( topt );
        d.cat   = ConfigCategoryId(tidy.OptGetCategory(topt))
        d.catid = tidy.OptGetCategory(topt)
        d.vals  = NULL;
        d.def   = NULL;
        d.haveVals = yes;

        # Handle special cases first.
        switch ( optId )
        {
        case TidyInlineTags:
        case TidyBlockTags:
        case TidyEmptyTags:
        case TidyPreTags:
            d.type = "Tag Names";
            d.vals = "tagX, tagY, ...";
            d.def  = NULL;
            break;

        case TidyPriorityAttributes:
            d.type = "Attributes Names";
            d.vals = "attributeX, attributeY, ...";
            d.def  = NULL;
            break;
            
        case TidyCharEncoding:
        case TidyInCharEncoding:
        case TidyOutCharEncoding:
            d.type = "Encoding";
            d.def  = tidyOptGetEncName( self.tdoc, optId ) or  "?"
            d.vals = NULL;
            break;
            
            # General case will handle remaining
        else:
            switch ( optTyp )
            {
            case tidy.TidyBoolean:
                d.type = "Boolean";
                d.def  = tidyOptGetCurrPick( self.tdoc, optId );
                break;
                
            case tidy.TidyInteger:
                if hasPickList(topt):
                    d.type = "Enum";
                    d.def  = tidyOptGetCurrPick( self.tdoc, optId );
                else:
                    uint idef;
                    d.type = "Integer";
                    if ( optId == TidyWrapLen )
                        d.vals = "0 (no wrapping), 1, 2, ...";
                    else:
                        d.vals = "0, 1, 2, ...";
                    
                    idef = tidyOptGetInt( self.tdoc, optId );
                    sprintf(d.tempdefs, "%u", idef);
                    d.def = d.tempdefs;
                break;
                
            case tidy.TidyString:
                d.type = "String";
                d.vals = NULL;
                d.haveVals = no;
                d.def  = tidyOptGetValue( self.tdoc, optId );
                break;
            }
        }

        return d

def PrintAllowedValuesFromPick(topt: TidyOption):
    """Prints an option's allowed value as specified in its pick list.
    @param topt The Tidy option.
    """
    pos: TidyIterator = tidyOptGetPickList( topt );
    first = True
    ctmbstr def;
    while pos:
        if first:
            first = no;
        else:
            printf(", ");
        def = tidyOptGetNextPick( topt, &pos );
        printf("%s", def);


def PrintAllowedValues(topt: TidyOption,       # The Tidy option.
                       const OptionDesc *d):  # The OptionDesc for the option.
    """Prints an option's allowed values.
    """
    if d->vals:
        printf( "%s", d->vals );
    else:
        PrintAllowedValuesFromPick( topt );


# @} end utilities_cli_options group

# MARK: - Provide the -help Service
# **************************************************************************** #
# @defgroup service_help Provide the -help Service
# **************************************************************************** #
# @{


tmbstr get_option_names( const CmdOptDesc* pos ):
    """Retrieve the option's name(s) from the structure as a single string,
    localizing the field values if application. For example, this might
    return `-output <file>, -o <file>`.
    @param pos A CmdOptDesc array item for which to get the names.
    @result Returns the name(s) for the option as a single string.
    """
    tmbstr name;
    uint len;
    CmdOptDesc localPos = *pos;

    localize_option_names( &localPos );

    len = strlen(localPos.name1);
    if (localPos.name2)
        len += 2+strlen(localPos.name2);
    if (localPos.name3)
        len += 2+strlen(localPos.name3);

    name = (tmbstr)malloc(len+1);
    if not name: outOfMemory();
    strcpy(name, localPos.name1);
    free((tmbstr)localPos.name1);
    if (localPos.name2)
    {
        strcat(name, ", ");
        strcat(name, localPos.name2);
        free((tmbstr)localPos.name2);
    }
    if (localPos.name3)
    {
        strcat(name, ", ");
        strcat(name, localPos.name3);
        free((tmbstr)localPos.name3);
    }

    return name;


ctmbstr get_final_name( ctmbstr prog ):
    """Returns the final name of the tidy executable by eliminating
    the path name components from the executable name.
    @param prog The path of the current executable.
    """
    ctmbstr name = prog;
    int c;
    size_t i;
    size_t len = strlen(prog);

    for (i = 0; i < len; i++):
        c = prog[i];
        if ((( c == '/' ) || ( c == '\\' )) and prog[i+1])
        {
            name = &prog[i+1];
        }

    return name;


    def help(self,
             ctmbstr prog):  # The path of the current executable.
        """Handles the -help service.
        """
        global ul

        tmbstr temp_string = NULL;
        uint width = 78;

        printf(tidy.LocalizedString(tidy.TC_TXT_HELP_1),
               get_final_name(prog), tidy.LibraryVersion().decode("utf-8"))
        print()

        if tidy.Platform():
            temp_string = stringWithFormat(tidy.LocalizedString(tidy.TC_TXT_HELP_2A),
                                           tidyPlatform() )
        else:
            temp_string = stringWithFormat(tidy.LocalizedString(tidy.TC_TXT_HELP_2B))

        width = width < strlen(temp_string) ? width : strlen(temp_string);
        printf( "%s\n", temp_string );
        printf( "%*.*s\n\n", width, width, ul);
        free( temp_string );

        self.print_help_options()

        print()
        #if defined(TIDY_CONFIG_FILE) and defined(TIDY_USER_CONFIG_FILE)
            temp_string = stringWithFormat(tidy.LocalizedString(tidy.TC_TXT_HELP_3A),
                                           TIDY_CONFIG_FILE, TIDY_USER_CONFIG_FILE);
            printf(tidy.LocalizedString(tidy.TC_TXT_HELP_3), temp_string)
            free(temp_string)
        #else
            printf(tidy.LocalizedString(tidy.TC_TXT_HELP_3), "\n" )
        #endif
        print()

    def print_help_options(self):
        """Outputs all of the complete help options (text).
        """
        global helpfmt

        CmdOptCategory cat = CmdOptCatFIRST;
        const CmdOptDesc* pos = cmdopt_defs;
        uint col1, col2;
        uint width = 78;

        for( cat=CmdOptCatFIRST; cat!=CmdOptCatLAST; ++cat):

            ctmbstr name = tidy.LocalizedString(cmdopt_catname[cat].key)
            size_t len = width < strlen(name) ? width : strlen(name);
            printf( "%s\n", name );
            printf( "%*.*s\n", (int)len, (int)len, helpul );

            # Tidy's "standard" 78-column output was always 25:52 ratio, so let's
            # try to preserve this approximately 1:2 ratio regardless of whatever
            # silly thing the user might have set for a console width, with a
            # maximum of 50 characters for the first column.
            #
            col1 = width / 3;              # one third of the available
            col1 = col1 < 1 ? 1 : col1;    # at least 1
            col1 = col1 > 35 ? 35 : col1;  # no greater than 35
            col2 = width - col1 - 2;       # allow two spaces
            col2 = col2 < 1 ? 1 : col2;    # at least 1

            for ( pos=cmdopt_defs; pos->name1; ++pos ):
                tmbstr name;
                if (pos->cat != cat)
                    continue;
                name = get_option_names( pos );
                Tidy.print2Columns(helpfmt,
                                   col1, col2, name,
                                   tidy.LocalizedString(pos->key))
                free(name);
            print()

# @} end service_help group

# MARK: - Provide the -help-config Service
# **************************************************************************** #
# @defgroup service_help_config Provide the -help-config Service
# **************************************************************************** #
# @{

tmbstr GetAllowedValuesFromPick(topt: TidyOption):
    """Retrieves allowed values from an option's pick list.
    @param topt A TidyOption for which to get the allowed values.
    @result A string containing the allowed values.
    """
    TidyIterator pos;
    Bool first;
    ctmbstr def;
    uint len = 0;
    tmbstr val;

    pos = tidyOptGetPickList( topt );
    first = yes;
    while pos:
        if first:
            first = no;
        else:
            len += 2;
        def = tidyOptGetNextPick( topt, &pos );
        len += strlen(def);

    val = (tmbstr)malloc(len+1);
    if (!val) outOfMemory();
    val[0] = '\0';
    pos = tidyOptGetPickList( topt );
    first = yes;
    while pos:
        if first:
            first = no;
        else:
            strcat(val, ", ");
        def = tidyOptGetNextPick( topt, &pos );
        strcat(val, def);

    return val;


tmbstr GetAllowedValues(topt: TidyOption,       # A TidyOption for which to get the allowed values.
                        const OptionDesc *d:)  # A pointer to the OptionDesc array.
    """Retrieves allowed values for an option.
    @result A string containing the allowed values.
    """
    if d->vals:
        tmbstr val = (tmbstr)malloc(1+strlen(d->vals));
        if (!val) outOfMemory();
        strcpy(val, d->vals);
        return val;
    else:
        return GetAllowedValuesFromPick( topt );


    def optionhelp(self):
        """Handles the -help-config service.
        @remark We will not support console word wrapping for the configuration
                options table. If users really have a small console, then they
                should make it wider or output to a file.
        """
        global fmt
        global ul

        print()
        printf("%s", tidy.LocalizedString(tidy.TC_TXT_HELP_CONFIG))

        print(fmt %
              (tidy.LocalizedString(tidy.TC_TXT_HELP_CONFIG_NAME),
               tidy.LocalizedString(tidy.TC_TXT_HELP_CONFIG_TYPE),
               tidy.LocalizedString(tidy.TC_TXT_HELP_CONFIG_ALLW)),
              end="")

        print(fmt % (ul, ul, ul), end="")

        self.tdoc.ForEachSortedOption(self.printOption)

    def printOption(self,
                    topt: TidyOption,  # The option to print.
                    OptionDesc *d):    # A pointer to the OptionDesc array.
        """Prints a single option.
        """
        global fmt

        if tidy.OptGetCategory(topt) == tidy.TidyInternalCategory:
            return

        if *d->name || *d->type:
            ctmbstr pval = d->vals;
            tmbstr val = NULL;
            if (!d->haveVals)
            {
                pval = "-";
            }
            else if (pval == NULL)
            {
                val = GetAllowedValues( topt, d);
                pval = val;
            }
            Tidy.print3Columns(fmt, 27, 9, 40, d->name, d->type, pval)
            if (val)
                free(val);

    # @} end service_help_config group

    # MARK: - Provide the -help-env Service
    # **************************************************************************** #
    # @defgroup service_help_env Provide the -help-env Service
    # **************************************************************************** #
    # @{

    def helpEnv(self):
        """Handles the -help-env service.
        """
        tmbstr subst = "";
        Bool uses_env = getenv("HTML_TIDY") != NULL;
        ctmbstr env_var = (uses_env ? getenv("HTML_TIDY") : tidy.LocalizedString(tidy.TC_TXT_HELP_ENV_1B))

        #if defined( TIDY_CONFIG_FILE ) and defined( TIDY_USER_CONFIG_FILE )
            subst = stringWithFormat(tidy.LocalizedString(tidy.TC_TXT_HELP_ENV_1A),
                                     TIDY_CONFIG_FILE, TIDY_USER_CONFIG_FILE)
        #endif

        env_var = (env_var != NULL ? env_var : tidy.LocalizedString(tidy.TC_TXT_HELP_ENV_1B))

        print()
        printf(tidy.LocalizedString(tidy.TC_TXT_HELP_ENV_1),
               subst, env_var)

        #if defined( TIDY_CONFIG_FILE ) and defined( TIDY_USER_CONFIG_FILE )
            if ( uses_env )
                printf(tidy.LocalizedString(tidy.TC_TXT_HELP_ENV_1C),
                       TIDY_USER_CONFIG_FILE)
            free( subst );
        #endif

        print()

    # @} end service_help_env group

# MARK: - Provide the -help-option Service
# **************************************************************************** #
# @defgroup service_help_option Provide the -help-option Service
# **************************************************************************** #
# @{


tmbstr cleanup_description( ctmbstr description ):
    """Cleans up the HTML-laden option descriptions for console output.
    It's just a simple HTML filtering/replacement function.
    @param description The option description.
    @result Returns an allocated string with some HTML stripped away.
    """
    # Substitutions - this might be a good spot to introduce platform
    # dependent definitions for colorized output on different terminals
    # that support, for example, ANSI escape sequences. The assumption
    # is made the Mac and Linux targets support ANSI colors, but even
    # so debugger terminals may not. Note that the line-wrapping
    # function also doesn't account for non-printing characters.
    static struct {
        ctmbstr tag;
        ctmbstr replacement;
    } const replacements[] = {
        { "lt",       "<"          },
        { "gt",       ">"          },
        { "br/",      "\n\n"       },
        #if defined(LINUX_OS) || defined(MAC_OS_X)
        { "code",     "\x1b[36m"   },
        { "/code",    "\x1b[0m"    },
        { "em",       "\x1b[4m"   },
        { "/em",      "\x1b[0m"    },
        { "strong",   "\x1b[31m"   },
        { "/strong",  "\x1b[0m"    },
        #endif
        # MUST be last
        { NULL,       NULL         },
    };

    # State Machine Setup
    typedef enum {
        s_DONE,
        s_DATA,
        s_WRITING,
        s_TAG_OPEN,
        s_TAG_NAME,
        s_ERROR,
        s_LAST  # MUST be last
    } states;

    typedef enum {
        c_NIL,
        c_EOF,
        c_BRACKET_CLOSE,
        c_BRACKET_OPEN,
        c_OTHER
    } charstates;

    typedef enum {
        a_NIL,
        a_BUILD_NAME,
        a_CONSUME,
        a_EMIT,
        a_EMIT_SUBS,
        a_WRITE,
        a_ERROR
    } actions;

    typedef struct {
        states state;
        charstates charstate;
        actions action;
        states next_state;
    } transitionType;

    const transitionType transitions[] = {
        { s_DATA,           c_EOF,           a_NIL,        s_DONE           },
        { s_DATA,           c_BRACKET_OPEN,  a_CONSUME,    s_TAG_OPEN       },
        # special case allows ;
        { s_DATA,           c_BRACKET_CLOSE, a_EMIT,       s_WRITING        },
        { s_DATA,           c_OTHER,         a_EMIT,       s_WRITING        },
        { s_WRITING,        c_OTHER,         a_WRITE,      s_DATA           },
        { s_WRITING,        c_BRACKET_CLOSE, a_WRITE,      s_DATA           },
        { s_TAG_OPEN,       c_EOF,           a_ERROR,      s_DONE           },
        { s_TAG_OPEN,       c_OTHER,         a_NIL,        s_TAG_NAME       },
        { s_TAG_NAME,       c_BRACKET_OPEN,  a_ERROR,      s_DONE           },
        { s_TAG_NAME,       c_EOF,           a_ERROR,      s_DONE           },
        { s_TAG_NAME,       c_BRACKET_CLOSE, a_EMIT_SUBS,  s_WRITING        },
        { s_TAG_NAME,       c_OTHER,         a_BUILD_NAME, s_TAG_NAME       },
        { s_ERROR,          0,               a_ERROR,      s_DONE           },
        { s_DONE,           0,               a_NIL,        0                },
        # MUST be last:
        { s_LAST,           0,               0,            0                },
    };

    # Output Setup
    tmbstr result = NULL;
    int g_result = 100;  # minimum buffer grow size
    int l_result = 0;    # buffer current size
    int i_result = 0;    # current string position
    int writer_len = 0;  # writer length

    ctmbstr writer = NULL;

    # Current tag name setup
    tmbstr name = NULL;  # tag name
    int g_name = 10;     # buffer grow size
    int l_name = 0;      # buffer current size
    int i_name = 0;      # current string position

    # Pump Setup
    int i = 0;
    states state = s_DATA;
    charstates charstate;
    char c;
    int j = 0, k = 0;
    transitionType transition;

    if ( !description || (strlen(description) < 1) )
    {
        return NULL;
    }

    # Process the HTML Snippet
    do {
        c = description[i];

        # Determine secondary state.
        switch (c)
        {
            case '\0':
                charstate = c_EOF;
                break;

            case '<':
            case '&':
                charstate = c_BRACKET_OPEN;
                break;

            case '>':
            case ';':
                charstate = c_BRACKET_CLOSE;
                break;

            default:
                charstate = c_OTHER;
                break;
        }

        # Find the correct instruction
        j = 0;
        while (transitions[j].state != s_LAST)
        {
            transition = transitions[j];
            if ( transition.state == state and transition.charstate == charstate ) {
                switch ( transition.action )
                {
                        # This action is building the name of an HTML tag.
                    case a_BUILD_NAME:
                        if ( !name )
                        {
                            l_name = g_name;
                            name = calloc(l_name, 1);
                        }

                        if ( i_name >= l_name )
                        {
                            l_name = l_name + g_name;
                            name = realloc(name, l_name);
                        }

                        strncpy(name + i_name, &c, 1);
                        i_name++;
                        i++;
                        break;

                        # This character will be emitted into the output
                        # stream. The only purpose of this action is to
                        # ensure that `writer` is NULL as a flag that we
                        # will output the current `c`
                    case a_EMIT:
                        writer = NULL;  # flag to use c
                        break;

                        # Now that we've consumed a tag, we will emit the
                        # substitution if any has been specified in
                        # `replacements`.
                    case a_EMIT_SUBS:
                        name[i_name] = '\0';
                        i_name = 0;
                        k = 0;
                        writer = "";
                        while ( replacements[k].tag )
                        {
                            if ( strcmp( replacements[k].tag, name ) == 0 )
                            {
                                writer = replacements[k].replacement;
                            }
                            k++;
                        }
                        break;

                        # This action will add to our `result` string, expanding
                        # the buffer as necessary in reasonable chunks.
                    case a_WRITE:
                        if ! writer:
                            writer_len = 1;
                        else:
                            writer_len = strlen( writer );
                        # Lazy buffer creation
                        if ( !result )
                        {
                            l_result = writer_len + g_result;
                            result = calloc(l_result, 1);
                        }
                        # Grow the buffer if needed
                        if ( i_result + writer_len >= l_result )
                        {
                            l_result = l_result + writer_len + g_result;
                            result = realloc(result, l_result);
                        }
                        # Add current writer to the buffer
                        if ( !writer )
                        {
                            result[i_result] = c;
                            result[i_result +1] = '\0';
                        }
                        else:
                        {
                            strncpy( result + i_result, writer, writer_len );
                        }

                        i_result += writer_len;
                        i++;
                        break;

                        # This action could be more robust but it serves the
                        # current purpose. Cross our fingers and count on our
                        # localizers not to give bad HTML descriptions.
                    case a_ERROR:
                        printf("<Error> The localized string probably has bad HTML.\n");
                        goto EXIT_CLEANLY;

                        # Just a NOP.
                    case a_NIL:
                        break;

                        # The default case also handles the CONSUME action.
                    default:
                        i++;
                        break;
                }

                state = transition.next_state;
                break;
            }
            j++;
        }
    } while ( description[i] );

    EXIT_CLEANLY:

    if ( name )
        free(name);

    return result;


    def optionDescribe(self,
                       option: str):  # The name of the option.
        """Handles the -help-option service.
        """
        tmbstr result = NULL;

        allocated = False
        topt: TidyOptionId = tidy.OptGetIdForName(option.encode("utf-8"))
        xxxx = tidyGetOption(self.tdoc, topt)
        uint tcat = tidy.OptGetCategory(tidyGetOption(self.tdoc, topt))

        if topt < tidy.N_TIDY_OPTIONS and tcat != tidy.TidyInternalCategory:
            result = cleanup_description( tidyOptGetDoc(self.tdoc,
                                                        tidyGetOption(self.tdoc, topt)) );
            allocated = True
        else:
            result = (tmbstr)tidy.LocalizedString(tidy.TC_STRING_UNKNOWN_OPTION_B)

        print()
        print("`--%s`\n" % option)
        Tidy.print1Column("%-78.78s\n", 78, result)
        print()

        if allocated:
            free ( result );

# @} end service_help_option group

# MARK: - Provide the -lang help Service
# **************************************************************************** #
# @defgroup service_lang_help Provide the -lang help Service
# **************************************************************************** #
# @{


def tidyPrintWindowsLanguageNames( ctmbstr format ):
    """Prints the Windows language names that Tidy recognizes, using the specified 
    format string.
    @param format A format string used to display the Windows language names,
           or NULL to use the built-in default format.
    """
    TidyIterator i = getWindowsLanguageList();
    while i:
        const tidyLocaleMapItem * item = getNextWindowsLanguage(&i);
        ctmbstr winName = TidyLangWindowsName( item );
        ctmbstr posixName = TidyLangPosixName( item );
        if format:
            printf( format, winName, posixName );
        else:
            printf( "%-20s -> %s\n", winName, posixName );


def tidyPrintTidyLanguageNames( ctmbstr format ):
    """Prints the languages the are currently built into Tidy, using the specified
    format string.
    @param format A format string used to display the Windows language names,
           or NULL to use the built-in default format.
    """
    TidyIterator i = getInstalledLanguageList();
    while i:
        ctmbstr item = getNextInstalledLanguage(&i);
        if format:
            printf( format, item );
        else:
            printf( "%s\n", item );

    def lang_help(self):
        """Handles the -lang help service.
        @remark We will not support console word wrapping for the tables. If users
                really have a small console, then they should make it wider or 
                output to a file.
        """
        print()
        printf("%s", tidy.LocalizedString(tidy.TC_TXT_HELP_LANG_1))
        print()
        tidyPrintWindowsLanguageNames("  %-20s -> %s\n");
        print()
        printf("%s", tidy.LocalizedString(tidy.TC_TXT_HELP_LANG_2))
        print()
        tidyPrintTidyLanguageNames("  %s\n");
        print()
        printf(tidy.LocalizedString(tidy.TC_TXT_HELP_LANG_3),
               tidy.GetLanguage().decode("utf-8"))
        print()

    # @} end service_lang_help group

    # MARK: - Provide the -show-config Service
    # **************************************************************************** #
    # @defgroup service_show_config Provide the -show-config Service
    # **************************************************************************** #
    # @{

    def optionvalues(self):
        """Handles the -show-config service.
        @remark We will not support console word wrapping for the table. If users
                really have a small console, then they should make it wider or
                output to a file.
        """
        print("\n%s" % tidy.LocalizedString(tidy.TC_STRING_CONF_HEADER))
        printf(fmt,
               tidy.LocalizedString(tidy.TC_STRING_CONF_NAME),
               tidy.LocalizedString(tidy.TC_STRING_CONF_TYPE),
               tidy.LocalizedString(tidy.TC_STRING_CONF_VALUE))
        printf( fmt, ul, ul, ul );

        self.tdoc.ForEachSortedOption(self.printOptionValues)

    def printOptionValues(self,
                          topt: TidyOption,  # The option for which to show values.
                          OptionDesc *d):    # The OptionDesc array.
        """Prints the option value for a given option.
        """
        optId: TidyOptionId = tidy.OptGetId(topt)

        if tidy.OptGetCategory(topt) == tidy.TidyInternalCategory:
            return

        switch ( optId )
        {
            case TidyInlineTags:
            case TidyBlockTags:
            case TidyEmptyTags:
            case TidyPreTags:
            {
                pos: TidyIterator = tidyOptGetDeclTagList(self.tdoc)
                while pos:
                    d->def = tidyOptGetNextDeclTag(self.tdoc, optId, &pos);
                    if ( pos )
                    {
                        printf( fmt, d->name, d->type, d->def );
                        d->name = "";
                        d->type = "";
                    }
            }
                break;
            case TidyPriorityAttributes:  # Is #697 - This case seems missing
            {
                TidyIterator itAttr = tidyOptGetPriorityAttrList(self.tdoc);
                if (itAttr and (itAttr != (TidyIterator)-1))
                {
                    while (itAttr)
                    {
                        d->def = tidyOptGetNextPriorityAttr(self.tdoc, &itAttr);
                        if (itAttr)
                        {
                            printf(fmt, d->name, d->type, d->def);
                            d->name = "";
                            d->type = "";
                        }
                    }
                }
            }
                break;
            default:
                break;
        }

        # fix for http://tidy.sf.net/bug/873921
        if ( *d->name || *d->type || (d->def and *d->def) )
        {
            if ( ! d->def )
                d->def = "";
            printf( fmt, d->name, d->type, d->def );
        }

# @} end service_show_config group

# MARK: - Provide the -export-config Services
# **************************************************************************** #
# @defgroup service_export_config Provide the -export-config Services
# **************************************************************************** #
# @{


def invertBuffer(TidyBuffer *src, TidyBuffer *dst):
    """Is #697 - specialised service to 'invert' a buffers content
    split on a space character
    """
    uint len = src->size;
    char *in = (char *)src->bp;
    char *cp;

    if not in:
        return

    while len:
        unsigned char uc;
        len--;
        uc = in[len];
        if (uc == ' ')
        {
            in[len] = 0;
            cp = &in[len + 1];
            if (dst->size)
                tidyBufAppend(dst, " ", 1);
            tidyBufAppend(dst, cp, strlen(cp));
        }
    if (dst->size)
        tidyBufAppend(dst, " ", 1);
    tidyBufAppend(dst, in, strlen(in));


    def exportOptionValues(self):
        """Handles the -export-config service.
        """
        ForEachSortedOption(self.tdoc, self.printOptionExportValues)

    def exportDefaultOptionValues(self):
        """Handles the -export-default-config service.
        """
        tidy.OptResetAllToDefault(self.tdoc)
        ForEachSortedOption(self.tdoc, self.printOptionExportValues)

    def printOptionExportValues(self,  # The Tidy document.
                                topt: TidyOption,          # The option for which to show values.
                                OptionDesc *d):           # The OptionDesc array.
        """Prints the option value for a given option.
        """
        optId: TidyOptionId = tidy.OptGetId(topt)

        TidyBuffer buf1, buf2;

        if tidy.OptGetCategory(topt) == tidy.TidyInternalCategory:
            return

        switch ( optId )
        {
            case TidyInlineTags:
            case TidyBlockTags:
            case TidyEmptyTags:
            case TidyPreTags:
            {
                pos: TidyIterator = tidyOptGetDeclTagList(self.tdoc)
                if ( pos )  # Is #697 - one or more values
                {
                    tidyBufInit(&buf1);
                    tidyBufInit(&buf2);
                    while (pos)
                    {
                        d->def = tidyOptGetNextDeclTag(self.tdoc, optId, &pos);
                        if (d->def)
                        {
                            if (buf1.size)
                                tidyBufAppend(&buf1, " ", 1);
                            tidyBufAppend(&buf1, (void *)d->def, strlen(d->def));
                        }
                    }
                    invertBuffer(&buf1, &buf2);  # Is #697 - specialised service to invert words
                    tidyBufAppend(&buf2, (void *)"\0", 1);  # is this really required?
                    printf("%s: %s\n", d->name, buf2.bp);
                    d->name = "";
                    d->type = "";
                    d->def = 0;
                    tidyBufFree(&buf1);
                    tidyBufFree(&buf2);
                }
            }
                break;
            case TidyPriorityAttributes:  # Is #697 - This case seems missing
            {
                TidyIterator itAttr = tidyOptGetPriorityAttrList(self.tdoc);
                if (itAttr and (itAttr != (TidyIterator)-1))
                {
                    tidyBufInit(&buf1);
                    while (itAttr)
                    {
                        d->def = tidyOptGetNextPriorityAttr(self.tdoc, &itAttr);
                        if (d->def)
                        {
                            if (buf1.size)
                                tidyBufAppend(&buf1, " ", 1);
                            tidyBufAppend(&buf1, (void *)d->def, strlen(d->def));
                        }
                    }
                    tidyBufAppend(&buf1, (void *)"\0", 1);  # is this really required?
                    printf("%s: %s\n", d->name, buf1.bp);
                    d->name = "";
                    d->type = "";
                    d->def = 0;
                    tidyBufFree(&buf1);
                }
            }
            break;
            default:
                break;
        }

        # fix for http://tidy.sf.net/bug/873921
        if ( *d->name || *d->type || (d->def and *d->def) )
        {
            if ( ! d->def )
                d->def = "";
            printf( "%s: %s\n", d->name, d->def );
        }

    # @} end service_export_config group

    # MARK: - Provide the -version Service
    # **************************************************************************** #
    # @defgroup service_version Provide the -version Service
    # **************************************************************************** #
    # @{

    def version(self):
        """Handles the -version service.
        """
        if tidy.Platform():
            print(tidy.LocalizedString(tidy.TC_STRING_VERS_A) %
                  (tidy.Platform().decode("utf-8"),
                   tidy.LibraryVersion().decode("utf-8")))
        else:
            print(tidy.LocalizedString(tidy.TC_STRING_VERS_B) %
                  tidy.LibraryVersion().decode("utf-8"))

    # @} end service_version group

    # MARK: - Provide the -xml-config Service
    # **************************************************************************** #
    # @defgroup service_xml_config Provide the -xml-config Service
    # **************************************************************************** #
    # @{

    def printXMLDescription(self,
                            topt: TidyOption):  # The option.
        """Prints for XML an option's <description>.
        """
        doc = tidy.OptGetDoc(self.tdoc, topt)
        if doc:
            print("  <description>%s</description>" % doc.decode("utf-8"))
        else:
            print("  <description />")
            print(tidy.LocalizedString(tidy.TC_STRING_OPT_NOT_DOCUMENTED) %
                  tidy.OptGetName(topt).decode("utf-8"), file=sys.stderr)

    def printXMLCrossRef(self,
                         topt: TidyOption):  # The option.
        """Prints for XML an option's `<seealso>`.
        """
        pos: TidyIterator = tidy.OptGetDocLinksList(self.tdoc, topt)
        while pos:
            optLinked: TidyOption = tidy.OptGetNextDocLinks(self.tdoc, ct.byref(pos))
            print("  <seealso>%s</seealso>" %
                  tidy.OptGetName(optLinked).decode("utf-8"))

    def printXMLCrossRefEqConsole(self,      # The Tidy document.
                                  topt: TidyOption):  # The option.
        """Prints for XML an option's `<eqconfig>`.
        """
        const CmdOptDesc* pos = cmdopt_defs;
        const CmdOptDesc* hit = NULL;
        CmdOptDesc localHit;
        enum { sizeBuffer = 50 };  # largest config name is 27 chars so far...
        char buffer[sizeBuffer];

        for ( pos=cmdopt_defs; pos->name1; ++pos ):
            snprintf(buffer, sizeBuffer, "%s:", tidyOptGetName( topt ));
            if ( pos->eqconfig and (strncmp(buffer, pos->eqconfig, strlen(buffer)) == 0) ):
                hit = pos;
                break;

        if hit:
            localHit = *hit;
            localize_option_names( &localHit );
            print("  <eqconsole>%s</eqconsole>" % get_escaped_name(localHit.name1))
            free((tmbstr)localHit.name1);
            if localHit.name2:
                print("  <eqconsole>%s</eqconsole>" % get_escaped_name(localHit.name2))
                free((tmbstr)localHit.name2);
            if localHit.name3:
                print("  <eqconsole>%s</eqconsole>" % get_escaped_name(localHit.name3))
                free((tmbstr)localHit.name3);
            if localHit.eqconfig:  # Is. #791
                free((tmbstr)localHit.eqconfig);
        else:
            print("  %s" % "  <eqconsole />")

    def XMLoptionhelp(self):
        """Handles the -xml-config service.
        """
        print('<?xml version="1.0"?>\n'
              '<config version="%s">' %
              tidy.LibraryVersion().decode("utf-8"))
        self.tdoc.ForEachOption(self.printXMLOption)
        print("</config>")

    def printXMLOption(self,     # The Tidy document.
                       topt: TidyOption,  # The option.
                        OptionDesc *d):   # The OptionDesc for the option.
        """Prints for XML an option.
        """
        if tidy.OptGetCategory(topt) == tidy.TidyInternalCategory:
            return

        printf( " <option class=\"%s\">\n", d->cat );
        printf  ("  <name>%s</name>\n",d->name);
        printf  ("  <type>%s</type>\n",d->type);
        if d->def:
            printf("  <default>%s</default>\n",d->def);
        else:
            print("  <default />")
        if d->haveVals:
            printf("  <example>");
            PrintAllowedValues( topt, d );
            print("</example>")
        else:
            print("  <example />")
        printXMLDescription( self.tdoc, topt );
        printXMLCrossRef( self.tdoc, topt );
        printXMLCrossRefEqConsole( self.tdoc, topt );
        print(" </option>")

    # @} end service_xml_config group

    # MARK: - Provide the -xml-error-strings Service
    # **************************************************************************** #
    # @defgroup service_xml_error_strings Provide the -xml-error-strings Service
    # **************************************************************************** #
    # @{

    def xml_error_strings(self):
        """Handles the -xml-error-strings service.
        This service is primarily helpful to developers who need to generate an
        updated list of strings to expect when using one of the message callbacks.
        Included in the output is the current string associated with the error
        symbol.
        """
        print('<?xml version="1.0"?>')
        print('<error_strings version="%s">' %
              tidy.LibraryVersion().decode("utf-8"))

        j: TidyIterator = tidy.getErrorCodeList()
        while j:
            uint errorCode = tidy.getNextErrorCode(ct.byref(j))
            ctmbstr localized_string = tidy.LocalizedString(errorCode)
            print(" <error_string>")
            print("  <name>%s</name>" %
                  tidy.ErrorCodeAsKey(errorCode).decode("utf-8"))
            if localized_string:
                printf("  <string class=\"%s\"><![CDATA[%s]]></string>\n",
                       tidy.GetLanguage().decode("utf-8"),
                       localized_string.decode("utf-8"))
            else:
                printf("  <string class=\"%s\">NULL</string>\n",
                       tidy.GetLanguage().decode("utf-8"))
            print(" </error_string>")
        
        print("</error_strings>")

    # @} end service_xml_error_strings group

    # MARK: - Provide the -xml-help Service
    # **************************************************************************** #
    # @defgroup service_xmlhelp Provide the -xml-help Service
    # **************************************************************************** #
    # @{

    def xml_help(self):
        """Provides the -xml-help service.
        """
        const CmdOptDesc* pos;
        CmdOptDesc localPos;

        printf("<?xml version=\"1.0\"?>\n"
               "<cmdline version=\"%s\">\n", tidy.LibraryVersion().decode("utf-8"))

        for ( pos=cmdopt_defs; pos->name1; ++pos ):
            localPos = *pos;
            localize_option_names(&localPos);
            printf(" <option class=\"%s\">\n", cmdopt_catname[pos->cat].mnemonic );
            self.print_xml_help_option_element("name", localPos.name1);
            self.print_xml_help_option_element("name", localPos.name2);
            self.print_xml_help_option_element("name", localPos.name3);
            self.print_xml_help_option_element("description", tidy.LocalizedString(pos->key))
            if pos->eqconfig:
                self.print_xml_help_option_element("eqconfig", localPos.eqconfig);
            else:
                print("  <eqconfig />")
            print(" </option>")

            if (localPos.name1) free((tmbstr)localPos.name1);
            if (localPos.name2) free((tmbstr)localPos.name2);
            if (localPos.name3) free((tmbstr)localPos.name3);
            if (localPos.eqconfig) free((tmbstr)localPos.eqconfig);  # Is. #791

        print("</cmdline>")

    @staticmethod
    def print_xml_help_option_element(ctmbstr element,  # XML element name.
                                      ctmbstr name):    # The contents of the element.
        """Outputs an XML element for a CLI option, escaping special characters as
        required. For example, it might print `<name>-output &lt;file&gt;</name>`.
        """
        if not name:
            return
        printf("  <%s>%s</%s>\n", element, get_escaped_name(name), element);

    # @} end service_xmlhelp group

    # MARK: - Provide the -xml-options-strings Service
    # **************************************************************************** #
    # @defgroup service_xml_opts_strings Provide the -xml-options-strings Service
    # **************************************************************************** #
    # @{

    def xml_options_strings(self):
        """Handles the -xml-options-strings service.
        This service is primarily helpful to developers and localizers to test
        that option description strings as represented on screen output are
        correct and do not break tidy.
        """
        printf("<?xml version=\"1.0\"?>\n"
               "<options_strings version=\"%s\">\n",
               tidy.LibraryVersion().decode("utf-8"))
        self.tdoc.ForEachOption(self.printXMLOptionString)
        print("</options_strings>")

    def printXMLOptionString(self,
                             topt: TidyOption,  # The option.
                             OptionDesc *d):    # The OptionDesc array.
        """Handles printing of option description for -xml-options-strings service.
        """
        if tidy.OptGetCategory(topt) == tidy.TidyInternalCategory:
            return
        print(" <option>")
        printf("  <name>%s</name>\n",d->name);
        printf("  <string class=\"%s\"><![CDATA[%s]]></string>\n",
               tidy.GetLanguage().decode("utf-8"),
               tidyOptGetDoc( self.tdoc, topt ))
        print(" </option>")

    # @} end service_xml_opts_strings group

# MARK: - Provide the -xml-strings Service
# **************************************************************************** #
# @defgroup service_xml_strings Provide the -xml-strings Service
# **************************************************************************** #
# @{


def xml_strings():
    """Handles the -xml-strings service.
    This service was primarily helpful to developers and localizers to compare
    localized strings to the built in `en` strings. It's probably better to use
    our POT/PO workflow with your favorite tools, or simply diff the language
    header files directly.
    @note The attribute `id` is not a specification, promise, or part of an
          API. You must not depend on this value. For strings meant for error
          output, the `label` attribute will contain the stringified version of
          the internal key for the string.
    """
    current_language = tidy.GetLanguage().decode("utf-8")
    skip_current     = (current_language in ["en"])

    printf("<?xml version=\"1.0\"?>\n"
           "<localized_strings version=\"%s\">\n",
           tidy.LibraryVersion().decode("utf-8"))

    j: TidyIterator = tidy.getStringKeyList()
    while j:
        i = tidy.getNextStringKey(ct.byref(j))
        current_label = tidy.ErrorCodeAsKey(i).decode("utf-8")
        if current_label == "UNDEFINED":
            current_label = ""
        print("<localized_string id=\"%u\" label=\"%s\">" %
              (i, current_label))
        print(" <string class=\"%s\">" % "en", end="")
        print("%s" % tidy.DefaultString(i).decode("utf-8"), end="")
        print("</string>")
        if not skip_current:
            matches_base = strcmp(tidy.LocalizedString(i), tidyDefaultString(i) ) == 0;
            print(" <string class=\"%s\" same_as_base=\"%s\">" %
                  (tidy.GetLanguage().decode("utf-8"),
                   ("yes" if matches_base else "no")), end="")
            print("%s" % tidy.LocalizedString(i), end="")
            print("</string>")
        print("</localized_string>")

    print("</localized_strings>")


# @} end service_xml_strings group

# MARK: - Experimental Stuff
# **************************************************************************** #
# @defgroup experimental_stuff Experimental Stuff
# From time to time the developers might leave stuff here that you can use
# to experiment on their own, or that they're using to experiment with.
# **************************************************************************** #
# @{


def TIDY_CALL reportCallback(tmessage: TidyMessage) -> bool:
    """This callback from LibTidy allows the console application to examine an
    error message before allowing LibTidy to display it. Currently the body
    of the function is not compiled into Tidy, but if you're interested in
    how to use the new message API, then enable it. Possible applications in
    future console Tidy might be to do things like:
    - allow user-defined filtering
    - sort the report output by line number
    - other things that are user facing and best not put into LibTidy
      proper.
    """
    if 0:
        TidyMessageArgument arg;
        TidyFormatParameterType messageType;
        ctmbstr messageFormat;

        print("FILTER: %s\n%s\n%s" % (tidyGetMessageKey(tmessage),
                                      tidyGetMessageOutput(tmessage),
                                      tidyGetMessageOutputDefault(tmessage)))
        
        # loop through the arguments, if any, and print their details
        pos: TidyIterator = tidy.GetMessageArguments(tmessage)
        while pos:
            arg = tidyGetNextMessageArgument( tmessage, &pos );
            messageType   = tidyGetArgType(tmessage, ct.byref(arg))
            messageFormat = tidyGetArgFormat(tmessage, ct.byref(arg))
            printf( "  Type = %u, Format = %s, Value = ", messageType, messageFormat );
            
            if messageType == tidyFormatType_STRING:
                printf("%s\n", tidyGetArgValueString( tmessage, &arg ));
            elif messageType == tidyFormatType_INT:
                printf("%d\n", tidyGetArgValueInt( tmessage, &arg));
            elif messageType == tidyFormatType_UINT:
                printf("%u\n", tidyGetArgValueUInt( tmessage, &arg));
            elif messageType == tidyFormatType_DOUBLE:
                printf("%g\n", tidyGetArgValueDouble( tmessage, &arg));
            else:
                print("%s" % "unknown so far")

        return False  # suppress LibTidy's own output of this message
    else:
        return True   # needed so Tidy will not block output of this message
    # endif

# @} end experimental_stuff group

# MARK: - Miscellaneous Utilities
# **************************************************************************** #
# @defgroup utilities_misc Miscellaneous Utilities
# This group contains general utilities used in the console application.
# **************************************************************************** #
# @{

def samefile(ctmbstr filename1,           # First filename
             ctmbstr filename2) -> bool:  # Second filename
    """Indicates whether or not two filenames are the same.
    @result Returns a Bool indicating whether the filenames are the same.
    """
    #if FILENAMES_CASE_SENSITIVE
        return ( strcmp( filename1, filename2 ) == 0 );
    #else
        return ( strcasecmp( filename1, filename2 ) == 0 );
    #endif

def tidy_cleanup():
    """Handles exit cleanup.
    """
    if is_windows:
        # Restore original Windows code page.
        global win_cp
        SetConsoleOutputCP(win_cp)
    # endif

# @} end utilities_misc group

# MARK: - main()
# **************************************************************************** #
# @defgroup main Main
# Let's do something here!
# **************************************************************************** #
# @{

int main( int argc, char** argv ):

    global errout

    ctmbstr prog = argv[0];
    ctmbstr errfil = NULL, htmlfil = NULL;

    status: int = 0

    uint contentErrors   = 0
    uint contentWarnings = 0
    uint accessWarnings  = 0

    #if defined(ENABLE_DEBUG_LOG) and defined(_MSC_VER)
    #  if defined(_CRTDBG_MAP_ALLOC)
        _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
    #  endif
    #endif

    tapp = Tidy()

    tidySetMessageCallback(tapp.tdoc, reportCallback)  # experimental group
    errout = sys.stderr  # initialize to sys.stderr

    # Set an atexit handler.
    atexit( tidy_cleanup );

    if is_windows:
        # Force Windows console to use UTF, otherwise many characters will
        # be garbage. Note that East Asian languages *are* supported, but
        # only when Windows OS locale (not console only!) is set to an
        # East Asian language.
        global win_cp
        win_cp = GetConsoleOutputCP()
        SetConsoleOutputCP(CP_UTF8)
    # endif

    # Look for default configuration files using any of
    # the following possibilities:
    #  - TIDY_CONFIG_FILE - from tidyplatform.h, typically /etc/tidy.conf
    #  - HTML_TIDY        - environment variable
    #  - TIDY_USER_CONFIG_FILE - from tidyplatform.h, typically ~/tidy.conf

    # ifdef TIDY_CONFIG_FILE
    if tidy.FileExists(tapp.tdoc, TIDY_CONFIG_FILE):
        status = tidyLoadConfig(tapp.tdoc, TIDY_CONFIG_FILE)
        if status != 0:
            fprintf(tidy.LocalizedString(tidy.TC_MAIN_ERROR_LOAD_CONFIG),
                    TIDY_CONFIG_FILE, status, file=errout)
            print(file=errout)
    # endif # TIDY_CONFIG_FILE #

    cfgfil = os.environ.get("HTML_TIDY")
    if cfgfil is not None:
        status = tidyLoadConfig(tapp.tdoc, cfgfil.encode("utf-8"))
        if status != 0:
            fprintf(tidy.LocalizedString(tidy.TC_MAIN_ERROR_LOAD_CONFIG),
                    cfgfil, status, file=errout)
            print(file=errout)
    # ifdef TIDY_USER_CONFIG_FILE
    elif tidy.FileExists(tapp.tdoc, TIDY_USER_CONFIG_FILE):
        status = tidyLoadConfig(tapp.tdoc, TIDY_USER_CONFIG_FILE)
        if status != 0:
            fprintf(tidy.LocalizedString(tidy.TC_MAIN_ERROR_LOAD_CONFIG),
                    TIDY_USER_CONFIG_FILE, status, file=errout)
            print(file=errout)
    # endif # TIDY_USER_CONFIG_FILE #

    #
    # Read command line
    #

    while ( argc > 0 )
    {
        if (argc > 1 and argv[1][0] == '-')
        {
            # support -foo and --foo
            ctmbstr arg = argv[1] + 1;

            if ( strcasecmp(arg, "xml") == 0)
                tidy.OptSetBool(tapp.tdoc, tidy.TidyXmlTags, True)
            else if ( strcasecmp(arg,   "asxml") == 0 ||
                      strcasecmp(arg, "asxhtml") == 0 )
                tidy.OptSetBool(tapp.tdoc, tidy.TidyXhtmlOut, True)
            else if ( strcasecmp(arg,   "ashtml") == 0 )
                tidy.OptSetBool(tapp.tdoc, tidy.TidyHtmlOut, True)
            else if ( strcasecmp(arg, "indent") == 0 )
                tidy.OptSetInt(tapp.tdoc, tidy.TidyIndentContent, tidy.TidyAutoState)
                if tidyOptGetInt(tapp.tdoc, tidy.TidyIndentSpaces) == 0:
                    tidy.OptResetToDefault(tapp.tdoc, tidy.TidyIndentSpaces)
            else if ( strcasecmp(arg, "omit") == 0 )
                tidy.OptSetBool(tapp.tdoc, tidy.TidyOmitOptionalTags, True)
            else if ( strcasecmp(arg, "upper") == 0 )
                tidy.OptSetBool(tapp.tdoc, tidy.TidyUpperCaseTags, True)
            else if ( strcasecmp(arg, "clean") == 0 )
                tidy.OptSetBool(tapp.tdoc, tidy.TidyMakeClean, True)
            else if ( strcasecmp(arg, "gdoc") == 0 )
                tidy.OptSetBool(tapp.tdoc, tidy.TidyGDocClean, True)
            else if ( strcasecmp(arg, "bare") == 0 )
                tidy.OptSetBool(tapp.tdoc, tidy.TidyMakeBare, True)
            else if ( strcasecmp(arg, "raw") == 0     ||
                      strcasecmp(arg, "ascii") == 0    ||
                      strcasecmp(arg, "latin0") == 0   ||
                      strcasecmp(arg, "latin1") == 0   ||
                      strcasecmp(arg, "utf8") == 0     ||
                      #ifndef NO_NATIVE_ISO2022_SUPPORT
                      strcasecmp(arg, "iso2022") == 0  ||
                      #endif
                      strcasecmp(arg, "utf16le") == 0  ||
                      strcasecmp(arg, "utf16be") == 0  ||
                      strcasecmp(arg, "utf16") == 0    ||
                      strcasecmp(arg, "shiftjis") == 0 ||
                      strcasecmp(arg, "big5") == 0     ||
                      strcasecmp(arg, "mac") == 0      ||
                      strcasecmp(arg, "win1252") == 0  ||
                      strcasecmp(arg, "ibm858") == 0 )
                tidySetCharEncoding(tapp.tdoc, arg)
            else if ( strcasecmp(arg, "numeric") == 0 )
                tidy.OptSetBool(tapp.tdoc, tidy.TidyNumEntities, True)
            else if ( strcasecmp(arg, "modify") == 0 ||
                      strcasecmp(arg, "change") == 0 ||  # obsolete
                      strcasecmp(arg, "update") == 0 )   # obsolete
                tidy.OptSetBool(tapp.tdoc, tidy.TidyWriteBack, True)
            else if ( strcasecmp(arg, "errors") == 0 )
                tidy.OptSetBool(tapp.tdoc, tidy.TidyShowMarkup, False)
            else if ( strcasecmp(arg, "quiet") == 0 )
                tidy.OptSetBool(tapp.tdoc, tidy.TidyQuiet, True)
            # Currently user must specify a language
            # prior to anything that causes output
            else if ( strcasecmp(arg, "language") == 0 ||
                      strcasecmp(arg,     "lang") == 0 )
                if argc >= 3:
                    if ( strcasecmp(argv[2], "help") == 0 )
                        tapp.lang_help()
                        exit(0);
                    if ( ! tidySetLanguage( argv[2] ) )
                        print(tidy.LocalizedString(tidy.TC_STRING_LANG_NOT_FOUND) %
                              (argv[2], tidy.GetLanguage().decode("utf-8")))
                    --argc;
                    ++argv;
                else:
                    printf("%s" %
                           tidy.LocalizedString(tidy.TC_STRING_LANG_MUST_SPECIFY).decode("utf-8"))
            else if ( strcasecmp(arg, "help") == 0 ||
                      strcasecmp(arg, "-help") == 0 ||
                      strcasecmp(arg,    "h") == 0 || *arg == '?' )
                tapp.help(prog)
                return 0  # success
            else if ( strcasecmp(arg, "xml-help") == 0)
                tapp.xml_help()
                return 0  # success
            else if ( strcasecmp(arg, "xml-error-strings") == 0)
                tapp.xml_error_strings()
                return 0  # success
            else if ( strcasecmp(arg, "xml-options-strings") == 0)
                tapp.xml_options_strings()
                return 0  # success
            else if ( strcasecmp(arg, "xml-strings") == 0)
                xml_strings( );
                return 0  # success
            else if ( strcasecmp(arg, "help-config") == 0 )
                tapp.optionhelp()
                return 0  # success
            else if ( strcasecmp(arg, "help-env") == 0 )
                helpEnv(tdoc)
                return 0  # success
            else if ( strcasecmp(arg, "help-option") == 0 )
                if argc >= 3:
                    tapp.optionDescribe(argv[2])
                else:
                    print("%s" %
                          tidy.LocalizedString(tidy.TC_STRING_MUST_SPECIFY).decode("utf-8"))
                return 0  # success
            else if ( strcasecmp(arg, "xml-config") == 0 )
                tapp.XMLoptionhelp()
                return 0  # success
            else if ( strcasecmp(arg, "show-config") == 0 )
                tapp.optionvalues()
                return 0  # success
            else if ( strcasecmp(arg, "export-config") == 0 )
                tapp.exportOptionValues()
                return 0  # success
            else if ( strcasecmp(arg, "export-default-config") == 0 )
                tapp.exportDefaultOptionValues()
                return 0  # success
            else if ( strcasecmp(arg, "config") == 0 )
            {
                if ( argc >= 3 )
                    ctmbstr post;

                    tidyLoadConfig( tdoc, argv[2] );

                    # Set new error output stream if setting changed
                    post = tidyOptGetValue(tdoc, tidy.TidyErrFile)
                    if post and (!errfil || !samefile(errfil, post)):
                        errfil = post;
                        errout = tidySetErrorFile( tdoc, post );

                    --argc;
                    ++argv;
            }
            else if ( strcasecmp(arg, "output") == 0 ||
                      strcasecmp(arg, "-output-file") == 0 ||
                      strcasecmp(arg, "o") == 0 )
            {
                if ( argc >= 3 )
                    tidyOptSetValue( tdoc, TidyOutFile, argv[2] );
                    --argc;
                    ++argv;
            }
            else if ( strcasecmp(arg,  "file") == 0 ||
                        strcasecmp(arg, "-file") == 0 ||
                        strcasecmp(arg,     "f") == 0 )
            {
                if ( argc >= 3 )
                {
                    errfil = argv[2];
                    errout = tidySetErrorFile( tdoc, errfil );
                    --argc;
                    ++argv;
                }
            }
            else if ( strcasecmp(arg,  "wrap") == 0 ||
                        strcasecmp(arg, "-wrap") == 0 ||
                        strcasecmp(arg,     "w") == 0 )
            {
                if ( argc >= 3 )
                {
                    uint wraplen = 0;
                    int nfields = sscanf( argv[2], "%u", &wraplen );
                    tidyOptSetInt( tdoc, TidyWrapLen, wraplen );
                    if (nfields > 0)
                    {
                        --argc;
                        ++argv;
                    }
                }
            }
            else if ( strcasecmp(arg,  "version") == 0 ||
                        strcasecmp(arg, "-version") == 0 ||
                        strcasecmp(arg,        "v") == 0 )
            {
                tapp.version()
                return 0  # success

            }
            else if ( strncmp(argv[1], "--", 2 ) == 0)
            {
                if ( tidyOptParseValue(tdoc, argv[1]+2, argv[2]) )
                {
                    # Set new error output stream if setting changed
                    ctmbstr post = tidyOptGetValue(tdoc, tidy.TidyErrFile)
                    if ( post and (!errfil || !samefile(errfil, post)) )
                    {
                        errfil = post;
                        errout = tidySetErrorFile( tdoc, post );
                    }

                    ++argv;
                    --argc;
                }
            }
                else if ( strcasecmp(arg, "access") == 0 )
                {
                    if ( argc >= 3 )
                    {
                        uint acclvl = 0;
                        int nfields = sscanf( argv[2], "%u", &acclvl );
                        tidyOptSetInt( tdoc, TidyAccessibilityCheckLevel, acclvl );
                        if (nfields > 0)
                        {
                            --argc;
                            ++argv;
                        }
                    }
                }

                else:
                {
                    uint c;
                    ctmbstr s = argv[1];

                    while ( (c = *++s) != '\0' )
                    {
                        switch ( c )
                        {
                        case 'i':
                            tidy.OptSetInt(tapp.tdoc, tidy.TidyIndentContent, tidy.TidyAutoState)
                            if tidyOptGetInt(tapp.tdoc, tidy.TidyIndentSpaces) == 0:
                                tidy.OptResetToDefault(tapp.tdoc, tidy.TidyIndentSpaces)
                            break;
                        case 'u':
                            tidy.OptSetBool(tapp.tdoc, tidy.TidyUpperCaseTags, True)
                            break;
                        case 'c':
                            tidy.OptSetBool(tapp.tdoc, tidy.TidyMakeClean, True)
                            break;
                        case 'g':
                            tidy.OptSetBool(tapp.tdoc, tidy.TidyGDocClean, True)
                            break;
                        case 'b':
                            tidy.OptSetBool(tapp.tdoc, tidy.TidyMakeBare, True)
                            break;
                        case 'n':
                            tidy.OptSetBool(tapp.tdoc, tidy.TidyNumEntities, True)
                            break;
                        case 'm':
                            tidy.OptSetBool(tapp.tdoc, tidy.TidyWriteBack, True)
                            break;
                        case 'e':
                            tidy.OptSetBool(tapp.tdoc, tidy.TidyShowMarkup, False)
                            break;
                        case 'q':
                            tidy.OptSetBool(tapp.tdoc, tidy.TidyQuiet, True)
                            break;
                        else:
                            unknownOption( tdoc, c );
                            break;
                        }
                    }
                }

            --argc;
            ++argv;
            continue;
        }


        if ( argc > 1 )
        {
            htmlfil = argv[1];
            #ifdef ENABLE_DEBUG_LOG
            SPRTF("Tidy: '%s'\n", htmlfil);
            #else # !ENABLE_DEBUG_LOG #
            # Is #713 - show-filename option
            if tidy.OptGetBool(tdoc, tidy.TidyShowFilename):
                fprintf(errout, "Tidy: '%s'", htmlfil);
                print(file=errout)
            #endif # ENABLE_DEBUG_LOG yes/no #
            if (tidy.OptGetBool(tdoc, tidy.TidyEmacs) ||
                tidy.OptGetBool(tdoc, tidy.TidyShowFilename)):
                tidySetEmacsFile( tdoc, htmlfil );
            status = tidyParseFile( tdoc, htmlfil );
        }
        else:
            htmlfil = "stdin";
            status = tidyParseStdin(tdoc)

        if status >= 0:
            status = tidyCleanAndRepair(tdoc)

        if status >= 0:
            status = tidyRunDiagnostics(tdoc)
        if status > 1:  # If errors, do we want to force output?
            if not tidy.OptGetBool(tdoc, tidy.TidyForceOutput):
                status = -1

        if status >= 0 and tidy.OptGetBool(tdoc, tidy.TidyShowMarkup):
            if tidy.OptGetBool(tdoc, tidy.TidyWriteBack) and argc > 1:
                status = tidySaveFile( tdoc, htmlfil );
            else:
                ctmbstr outfil = tidyOptGetValue( tdoc, TidyOutFile );
                if outfil:
                    status = tidySaveFile( tdoc, outfil );
                else:
                    #ifdef ENABLE_DEBUG_LOG
                    static char tmp_buf[264];
                    sprintf(tmp_buf,"%s.html",get_log_file());
                    status = tidySaveFile( tdoc, tmp_buf );
                    SPRTF("Saved tidied content to '%s'\n",tmp_buf);
                    #else
                    status = tidySaveStdout(tdoc)
                    #endif

        contentErrors   += tidyErrorCount(tdoc)
        contentWarnings += tidyWarningCount(tdoc)
        accessWarnings  += tidyAccessWarningCount(tdoc)

        --argc;
        ++argv;

        if argc <= 1:
            break
    }  # read command line loop

    # blank line for screen formatting
    if (errout is sys.stderr and contentErrors == 0 and
        not tidy.OptGetBool(tdoc, tidy.TidyQuiet)):
        print(file=errout)

    # footnote printing only if errors or warnings
    if contentErrors + contentWarnings > 0:
        tidy.ErrorSummary(tdoc)

    # prints the general info, if applicable
    tidy.GeneralInfo(tdoc)

    # called to free hash tables etc.
    tidy.Release(tdoc)
    
    # return status can be used by scripts
    if contentErrors > 0:
        return 2
    
    if contentWarnings > 0:
        return 1
    
    # 0 signifies all is ok
    return 0


# @} end main group

# @} end console_application group
